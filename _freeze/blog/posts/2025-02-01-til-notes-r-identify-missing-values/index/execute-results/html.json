{
  "hash": "e35a4af13195be53c7a0a78d3c160193",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TIL: Identifying explicit and implicit missing values\"\ndescription: \"Highlights from the DSLC book club discussion of Chapter 18: Missing values from R4DS\"\ndate: \"2025-02-01\"\nauthor: \"Collin K. Berke, Ph.D.\"\ndraft: false\ntoc: true\ncode-link: true\ncode-copy: true\nfrom: markdown+emoji\ncategories:\n  - til\n  - notes\n  - links\n  - data wrangling\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(skimr)\nlibrary(nycflights13)\n```\n:::\n\n\n\nToday I learned more about identifying explicit and missing values in R.\nDuring our weekly [Data Science Learning Community's (DSLC)](https://dslc.io/) [bookclub meeting for the R for Data Science (R4DS) book](https://youtu.be/hbDKS0V1MQE?si=QEGdZA1gPZCEnhEr), I was re-introduced to several methods to identify explicit and implicit missing values.\nMuch of what is covered here comes from [Chapter 18: Missing values](https://r4ds.hadley.nz/missing-values) of the book.\nI wanted to share what I've learned, in hopes I can better remember this information in the future.\n\n# Identify and count missing values\n\nWhen faced with a dataset, the need to identify the presence of and estimate the extent of explicit missing values (i.e., `NA`s) may come up.\nI made note of four different approaches from our discussion, which all output the same information.\n\n## Base R's `sapply()`\n\nThe first suggestion was to use base R's `sapply()` with an anonymous function.\nThere's two variations: one that identifys the presence of any `NA`s across the columns.\nThe second provides a count of `NA`s for each column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(starwars, function(x) any(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name     height       mass hair_color skin_color  eye_color birth_year        sex     gender \n     FALSE       TRUE       TRUE       TRUE      FALSE      FALSE       TRUE       TRUE       TRUE \n homeworld    species      films   vehicles  starships \n      TRUE       TRUE      FALSE      FALSE      FALSE \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(starwars, function(x) sum(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      name     height       mass hair_color skin_color  eye_color birth_year        sex     gender \n         0          6         28          5          0          0         44          4          4 \n homeworld    species      films   vehicles  starships \n        10          4          0          0          0 \n```\n\n\n:::\n:::\n\n\n\n## `purrr::map_df` with `any()` and `is.na()`\n\nSimilar to the base R approach is the use of `purrr::map_df()` with an anonymous function.\nI'm quite partial to this approach, as it's even more succinct, though it requires `purrr` as a dependency.\nHowever, if you're already importing the `tidyverse` into your session, then why not go ahead and use it?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(starwars, \\(x) any(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 14\n  name  height mass  hair_color skin_color eye_color birth_year sex   gender homeworld species films\n  <lgl> <lgl>  <lgl> <lgl>      <lgl>      <lgl>     <lgl>      <lgl> <lgl>  <lgl>     <lgl>   <lgl>\n1 FALSE TRUE   TRUE  TRUE       FALSE      FALSE     TRUE       TRUE  TRUE   TRUE      TRUE    FALSE\n# ℹ 2 more variables: vehicles <lgl>, starships <lgl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(starwars, \\(x) sum(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 14\n   name height  mass hair_color skin_color eye_color birth_year   sex gender homeworld species films\n  <int>  <int> <int>      <int>      <int>     <int>      <int> <int>  <int>     <int>   <int> <int>\n1     0      6    28          5          0         0         44     4      4        10       4     0\n# ℹ 2 more variables: vehicles <int>, starships <int>\n```\n\n\n:::\n:::\n\n\n\n## `dplyr::summarise()`\n\nAnother approach involved the use of `dplyr`'s `summarise()` along with `across()`, `everything()`, and an anonymous function.\nThis approach was meant only to count the amount of missing values within each column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarwars |>\n  summarise(across(everything(), \\(x) sum(is.na(x))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 14\n   name height  mass hair_color skin_color eye_color birth_year   sex gender homeworld species films\n  <int>  <int> <int>      <int>      <int>     <int>      <int> <int>  <int>     <int>   <int> <int>\n1     0      6    28          5          0         0         44     4      4        10       4     0\n# ℹ 2 more variables: vehicles <int>, starships <int>\n```\n\n\n:::\n:::\n\n\n\n## `skimr::skim()`\n\n`skimr::skim()` was also discussed, though the output is more verbose than the other options.\nThe output contains a sum of the number of missing values within each column.\nThis is certainly the most succinct way to obtain this information, and it provides additional summary information about your data.\nHowever, it may be more information then you need to answer your question about the presence of missing values in your data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nskim(starwars)\n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |         |\n|:------------------------|:--------|\n|Name                     |starwars |\n|Number of rows           |87       |\n|Number of columns        |14       |\n|_______________________  |         |\n|Column type frequency:   |         |\n|character                |8        |\n|list                     |3        |\n|numeric                  |3        |\n|________________________ |         |\n|Group variables          |None     |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|name          |         0|          1.00|   3|  21|     0|       87|          0|\n|hair_color    |         5|          0.94|   4|  13|     0|       11|          0|\n|skin_color    |         0|          1.00|   3|  19|     0|       31|          0|\n|eye_color     |         0|          1.00|   3|  13|     0|       15|          0|\n|sex           |         4|          0.95|   4|  14|     0|        4|          0|\n|gender        |         4|          0.95|   8|   9|     0|        2|          0|\n|homeworld     |        10|          0.89|   4|  14|     0|       48|          0|\n|species       |         4|          0.95|   3|  14|     0|       37|          0|\n\n\n**Variable type: list**\n\n|skim_variable | n_missing| complete_rate| n_unique| min_length| max_length|\n|:-------------|---------:|-------------:|--------:|----------:|----------:|\n|films         |         0|             1|       24|          1|          7|\n|vehicles      |         0|             1|       11|          0|          2|\n|starships     |         0|             1|       16|          0|          5|\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate|   mean|     sd| p0|   p25| p50|   p75| p100|hist  |\n|:-------------|---------:|-------------:|------:|------:|--:|-----:|---:|-----:|----:|:-----|\n|height        |         6|          0.93| 174.60|  34.77| 66| 167.0| 180| 191.0|  264|▂▁▇▅▁ |\n|mass          |        28|          0.68|  97.31| 169.46| 15|  55.6|  79|  84.5| 1358|▇▁▁▁▁ |\n|birth_year    |        44|          0.49|  87.57| 154.69|  8|  35.0|  52|  72.0|  896|▇▁▁▁▁ |\n\n\n:::\n:::\n\n\n\n# Identify implicit missing values with `dplyr::anti_join()`\n\nImplicit missing values were also an interesting topic of discussion.\nAccording to the R4DS book, implicit missing values are absent data without any observable reference to it being missing within the data.\n\nThis was such an important topic that even an exercise was devoted to it.\nDuring the reading, we learned how to use `dplyr::anti_join()` to help identify implicit missing values.\n\nHere's the solution, graciously shared by [Stephan Koenig](https://stephankoenig.me/about) with the group (see around [01m38s](https://youtu.be/hbDKS0V1MQE?si=2w3OJ9o_6r40vI0v&t=98)):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  select(tailnum, carrier) |>\n  anti_join(planes, by = join_by(tailnum)) |>\n  distinct(tailnum, carrier) |>\n  count(carrier, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   carrier     n\n   <chr>   <int>\n 1 AA        430\n 2 MQ        234\n 3 UA         23\n 4 FL         12\n 5 DL         10\n 6 US          9\n 7 B6          3\n 8 F9          3\n 9 WN          3\n10 9E          1\n```\n\n\n:::\n:::\n\n\n\nI really liked this approach.\nIt was useful to see the utility of `count()` to show which carriers had the most implicitly missing values within the flights data.\nHowever, it took me a beat to fully understand what was happening.\nI think this was due to the volume of data within the `flights` dataset used for the example.\nAs such, I thought up a simpler dataset, semi-related to the domain I work in, to help clarify my understanding of what's happening here.\n\nLet's say we're a marketer, and we run marketing campaigns to sell products through an ecommerce store.\nAs part of this store, we collect data about specific marketing campaigns and customers' purchases.\nData include a `campaign` data set, which contains metadata for each campaign.\nFor instance, data on the type of campaign being run.\nWe also have an `events` tibble, which contains data about whether a customer purchased items while visiting our ecommerce store, and if so, how much revenue was generated from their purchase.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncampaign <- tibble(\n  campaign_id = c(1, 2),\n  campaign_type = c(\"email\", \"social media\"),\n  campaign_name = c(\"Spring sale\", \"Winter clearance\")\n)\n\nevents <- tibble(\n  campaign_id = c(1, 2, 2, 1, 3, 3),\n  type = c(\n    \"no purchase\",\n    \"purchase\",\n    \"purchase\",\n    \"no purchase\",\n    \"no purchase\",\n    \"purchase\"\n  ),\n  revenue = c(0, 11.25, 25.37, 0, 0, 7.45)\n)\n```\n:::\n\n\n\nThe implicitly missing data is in the `campaign` dataset.\nSpecifically, we're missing campaign information for `campaign_id = 3`.\nThat is, there is no explicit reference for us to see that data is missing if we only looked at the `campaign` dataset.\nWe would only know we have missing values by joining these two datasets together.\n\nMissing data could be made more explicit in our `campaign` dataset by performing a [left join](https://r4ds.hadley.nz/joins#mutating-joins).\nThen, the approaches discussed above and `count()` can be used to identify and sum up how many events are missing campaign information.\nWe do something like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify the presence of missing\nevents |>\n  left_join(campaign) |>\n  map_df(\\(x) any(is.na(x)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(campaign_id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  campaign_id type  revenue campaign_type campaign_name\n  <lgl>       <lgl> <lgl>   <lgl>         <lgl>        \n1 FALSE       FALSE FALSE   TRUE          TRUE         \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count how many events are missing\nevents |>\n  anti_join(campaign, by = join_by(campaign_id)) |>\n  count(campaign_id, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  campaign_id     n\n        <dbl> <int>\n1           3     2\n```\n\n\n:::\n:::\n\n\n\nIndeed, this seems trivial given the size of the data.\nHowever, if the data had thousands or tens of thousands of purchase events and multiple campaigns running during a specific time period, this approach would be quite handy to help quickly identify which campaigns were missing data.\n\n# Wrap up\n\nKnowing how to identify missing values within data is important.\nThere are different strategies for identifying explicit or implict missing values.\nIn this post, I highlighted and made notes about the approaches discussed in the [R4DS book](https://r4ds.hadley.nz/missing-values) and our [DSLC book club meeting](https://youtu.be/hbDKS0V1MQE?si=Zq76wVUVcy6czpue).\n\nHappy data wrangling!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}