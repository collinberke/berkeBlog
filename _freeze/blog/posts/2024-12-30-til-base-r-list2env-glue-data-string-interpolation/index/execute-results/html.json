{
  "hash": "95bb192c2a4e7e6dcbe098ee8b5d155a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Use `list2env()` or `glue::glue_data()` to use a set of elements from a tibble in a string\"\ndescription: \"Need an easy way to access a set of elements from a tibble for string interpolation? Here's two examples\"\ndate: \"2024-12-30\"\nauthor: \"Collin K. Berke, Ph.D.\"\ndraft: false\nimage: thumbnail.jpg\ntoc: true\ncode-link: true\ncode-copy: true\nfrom: markdown+emoji\ncategories:\n  - til\n  - base r\n  - data wrangling\nformat:\n  html:\n    other-links:\n      - text: \"base::list2env()'s documentation\"\n        href: https://rdrr.io/github/robertzk/monadicbase/man/list2env.html\n      - text: \"glue::glue_data()'s documentation\"\n        href: https://glue.tidyverse.org/reference/glue.html\n---\n\n\n\n\n![Photo by [Ben Neale](https://unsplash.com/photos/green-white-and-gray-illustration-sQQf8Ao3dpk)](thumbnail-wide.jpg){fig-align=\"center\"}\n\n# Motivation\n\nToday I learned base R's `list2env()` function can be used to assign a set of variables to the Global Environment.\n\nFor a personal project, I was creating a simple CRUD application using [Shiny](https://shiny.posit.co/).\nThe purpose of the application was pretty straightforward: to serve as a tool for entering data into a database.\nThe app had the following requirements:\n\n* Provide inputs as fields for users to enter data that will be stored in a database.\n* Display entered data via the user interface for easy visual inspection before writing data to the database.\n* Include a 'Submit' button for the user to submit the data to the database.\n\nOn the back end of this simple app, data was stored in the Global Environment as a tibble, so it could be easily displayed via the application's UI.\nThe tibble only contained one row of data, where the values in the variable were to be written via a SQL `INSERT` statement upon the user hitting a 'Submit' button.\n\nWhile working on this part of the app, my initial approach confronted me with a [code smell](https://www.youtube.com/watch?v=7oyiPBjLAWY).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(glue)\n```\n:::\n\n\n\n\n# This approach stinks\n\nThe additional nuances of the Shiny application are not important.\nRather, let's focus on the actual problem I was confronted with: how do you create Global Environment variables from an existing object, specifically a `tibble` in my case?\n\nHere's some example data to work with:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_employee <- tibble(\n  first_name = \"John\",\n  last_name = \"Smith\",\n  start_date = \"2024-03-04\",\n  department = \"accounting\"\n)\n```\n:::\n\n\n\n\nAt this point, there is one object in the Global Environment, `data_employee`.\nTo prove this, let's submit `ls()` to the console, which will print all the objects in our current Global Environment.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data_employee\"\n```\n\n\n:::\n:::\n\n\n\n\nWhat if I also wanted the tibble's variables to be their own objects?\nThat is, I wanted code resulting in four objects being made available in the Global Environment, each containing a value from a variable in the tibble: `first_name`, `last_name`, `start_date`, and `department`.\n\nMy overall aim in doing this was to pass the values of these variables to a SQL `INSERT` statement using the `glue()` package:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_insert <- glue(\"\n  INSERT INTO employees (\n      first_name,\n      last_name,\n      start_date,\n      department\n  )\n  VALUES (\n      {first_name},\n      {last_name},\n      {start_date},\n      {department}\n  )\n\")\n```\n:::\n\n\n\n\nMy initial solution was to do this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_name <- data_employee[[\"first_name\"]]\nlast_name  <- data_employee[[\"last_name\"]]\nstart_date <- data_employee[[\"start_date\"]]\ndepartment <- data_employee[[\"department\"]]\n```\n:::\n\n\n\n\nIndeed, we can confirm this works by once again submitting `ls()` to the console.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data_employee\" \"department\"    \"first_name\"    \"last_name\"     \"start_date\"   \n```\n\n\n:::\n:::\n\n\n\n\nFurther confirmation results from inspecting the SQL `INSERT` statement string outputted from our use of the `glue()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_insert <- glue(\"\n  INSERT INTO employees (\n      first_name,\n      last_name,\n      start_date,\n      department\n  )\n  VALUES (\n      {first_name},\n      {last_name},\n      {start_date},\n      {department}\n  )\n\")\n\nquery_insert\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nINSERT INTO employees (\n    first_name,\n    last_name,\n    start_date,\n    department\n)\nVALUES (\n    John,\n    Smith,\n    2024-03-04,\n    accounting\n)\n```\n\n\n:::\n:::\n\n\n\n\nThis approach, though it works and isn't too cumbersome for this specific example, it stinks and feels off.\nThis especially became apparent when writing this out for the 10 fields of data I wanted to store within a database.\nI even physically cringed when I implemented it within the context of my application.\nThere had to be a better way.\n\nLet's start fresh by clearing the Global Environment, but keep our `data_employee` tibble to try another approach:\n\n::: {.callout-note}\nI wouldn't do this in my actual code. But I'm doing it here to better highlight the example.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(\n  first_name,\n  last_name,\n  start_date,\n  department,\n  query_insert\n)\n\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data_employee\"\n```\n\n\n:::\n:::\n\n\n\n\n# Base R's `list2env()`\n\n`list2env()` was the solution I was looking for.\nHere's the description from the function's documentation:\n\n> From a *named* `list x`, create an `envrionment` containing all list components as objects, or \"multi-assign\" from `x` into a pre-existing environment.\n\nA little esoteric, so I found the following resources to be quite helpful:\n\n* [Iteratively create global environment objects from tibble (Stack Overflow post)](https://stackoverflow.com/questions/69470394/iteratively-create-global-environment-objects-from-tibble)\n\n* [Dynamic variable assignment in R](https://www.evan-soil.io/blog/dynamic-variable-assignment-in-r/)\n\nEnvironments are an advanced topic, though a little context is helpful.\nEnvironments are just like any other data structure in R, but they serve as fenced object containers that can hold objects (my shallow interpretation).\nThe Global Environment is one such container that can hold objects for an R session, though additional named environments could be created.\nAs such, `list2env()` provides functionality to write named objects stored from a list to any environment we specify.\nReview [Chapter 7: Environments](https://adv-r.hadley.nz/environments.html) from the [Advanced R](https://adv-r.hadley.nz/) book for additional detail.\n\nUsing these concepts and `list2env()`, here's how I fixed my code smell:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist2env(data_employee, .GlobalEnv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data_employee\" \"department\"    \"first_name\"    \"last_name\"     \"start_date\"   \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nquery_insert <- glue(\"\n  INSERT INTO employees (\n      first_name,\n      last_name,\n      start_date,\n      department\n  )\n  VALUES (\n      {first_name},\n      {last_name},\n      {start_date},\n      {department}\n  )\n\")\n\nquery_insert\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nINSERT INTO employees (\n    first_name,\n    last_name,\n    start_date,\n    department\n)\nVALUES (\n    John,\n    Smith,\n    2024-03-04,\n    accounting\n)\n```\n\n\n:::\n:::\n\n\n\n\nðŸ¤¯.\n\nWhat was once ~10 lines of messy, smelly code is now a one-liner.\nI was shook upon learning this.\n\n# Wrap up\n\nThe take away from this TIL is a game changer: use `list2env()` if you need to convert existing list elements into objects in your Global Environment.\nI certainly was witness to its utility when trying to solve my own code smell.\nI hope you can find a use for it in your own work.\n\nUntil next time, cheers! ðŸŽ‰\n\n# A follow up: `glue::glue_data()`\n\n\n\n\n\n\n\n\n\nThanks to the power of community, [Tan Ho](https://tanho.ca/) shared an even less anti-pattern-ish / code-smell-ish solution to my problem in the [Data Science Learning Community's Slack channel](https://dslc.io/).\nHe suggested using `glue::glue_data()`.\n\nHere's how it works:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglue_data(\n  data_employee,\n  \"\n  INSERT INTO employees (\n      first_name,\n      last_name,\n      start_date,\n      department\n  )\n  VALUES (\n      {first_name},\n      {last_name},\n      {start_date},\n      {department}\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nINSERT INTO employees (\n    first_name,\n    last_name,\n    start_date,\n    department\n)\nVALUES (\n    John,\n    Smith,\n    2024-03-04,\n    accounting\n```\n\n\n:::\n:::\n\n\n\n\nðŸ¤¯ðŸ¤¯.\n\nThis works as expected and comes with a couple added benefits.\nFor one, the code's simpler.\nIn addition, we're no longer creating variables that only get used once. The Global Environment is now much cleaner.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}