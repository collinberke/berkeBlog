{
  "hash": "0e48b0ff52f6bcd73786e4129483ee78",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Notes: On the use of `...` in R\"\ndescription: \"What I recently learned about this slippery construct\"\ndate: \"2025-10-26\"\nauthor: \"Collin K. Berke, Ph.D.\"\ndraft: false\nimage: false\ntoc: true\ncode-link: true\ncode-copy: true\nfrom: markdown+emoji\ncategories:\n  - til\n  - notes\n  - links\n---\n\n\n\n\n\n\n> The `...` construct can be a slippery thing to get a hold of until you know the trick.\n>\n> -- [R Inferno section 8.3.15](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf)\n\nThe first step toward improvement is admiting you have a problem.\nMy problem?\nUnderstanding the dot-dot-dot (i.e., `...`) when it comes to writing functions in R.\nI had an intuitive sense of how `...`s worked, especially when using functions that had these as part of their implementation.\nI struggled, though, when applying them to my own self-defined functions.\nA few questions would constantly arise: Am I implementing these correctly? What am I missing?\nThese notes are thus:\n\n* An admission of my lack of explicit knowledge on the use of dots.\n* An attempt to better understand the use of `...`s through drafting some notes.\n* Evidence that I wresteled with their use to better understand what they are, how they work, and when to use them when defining my own functions in R.\n\n::: {.callout-note}\nThis post is written in the spirit of [publishing more frequent blog posts](https://www.collinberke.com/til/posts/2025-01-26-til-notes-quotes-links-credibility-blogs/).\nIt's a bit of a scratchpad of ideas, concepts, and/or ways of working that I found to be useful and interesting.\nAs such, what's here is lightly edited.\nBe aware: there will likely be spelling, grammatical, or syntactical errors along with some disjointed, incomplete ideas.\n:::\n\n# What are the `...`?\n\nIn terms of naming conventions, the dot-dot-dot is most commonly referred to as dots, three-dots, or just `...`.\n\nThe [Advanced R](https://adv-r.hadley.nz/) book by [Hadley Wickham](https://bsky.app/profile/hadley.nz) contains a concise and useful [explanation](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot).\nTo summarise, `...`s are a special argument.\nWhen applied to a function, that function can take, as inputs, any additional arguments.\nDots can also be used to pass arguments to another function.\nThis is referred to as [*forwarding* arguments](https://rlang.r-lib.org/reference/dyn-dots.html).\n\nA [blog post](https://www.burns-stat.com/the-three-dots-construct-in-r/) from Burns Statistics further states `...` allows for:\n\n* an aribitraty number and variety of arguments.\n* passing arguments on to other functions.\n\nSimplifying further, [Josiah Parry](https://bsky.app/profile/josiahparry.com) has a really good [YouTube video](https://www.youtube.com/watch?v=oIMFZf5dUFA) overviewing `...` fundamentals.\nThe key point made in the video is dots are used to pass arguments ([01M38S](https://youtu.be/oIMFZf5dUFA?si=FvjTjOmw68J8e3hm&t=98)).\nIn addition, the video explains another interesting expression of the power of dots ([03M22S](https://youtu.be/oIMFZf5dUFA?si=gaz8kwWwt32d6fVV&t=202)):\n\n> it lets us take different objects restructure them into the required format then pass an arguments to another function.\n\nThis is known as *capturing* or *collecting* arguments passed to dots, a powerful utility. \nThis use of dots will be discussed later in these notes.\n\nI highly suggest reviewing this video.\nIt was a resource about the basics of `...` which just clicked for me.\n\nMany R functions implement the `...`, including but not limited to those of Base R and the Tidyverse.\nHere are a few examples of functions that implement `...` into their API.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dot-dot-dots everywhere\nargs(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (...) \nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nargs(list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (...) \nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nargs(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, ...) \nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nargs(dplyr::filter)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (.data, ..., .by = NULL, .preserve = FALSE) \nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nargs(purrr::map)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (.x, .f, ..., .progress = FALSE) \nNULL\n```\n\n\n:::\n:::\n\n\n\n\n# How are the `...`s used?\n\nLet's observe `...`s in action.\nFor one, dots can pass arguments along to other functions, referred to as forwarding.\nHere's an example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use `...` to forward arguments to other functions\nfn01 <- function(x, y) {\n  c(\"val1\" = x, \"val2\" = y)\n}\n\nfn02 <- function(z, ...) {\n  fn01(...)\n}\n\nfn02(x = 1, y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nval1 val2 \n   1    2 \n```\n\n\n:::\n:::\n\n\n\n\nIndeed,\n\n> [When you write a function using the three-dots, you always have to pass it to some function (in order for it to be useful).](https://www.burns-stat.com/the-three-dots-construct-in-r/).\n\nThis is pretty straight forward when you want to pass additional arguments to a *specific* function in your own function definitions, like the example code above.\n\nHowever, if you need more control, then the arguments passed need to be captured using a list.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Capturing for more control\nfn03 <- function(...) {\n  dots <- list(...)\n  print(dots)\n}\n\nfn03(x = 1, y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n[1] 1\n\n$y\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\nOnce captured, the objects within the list can be later indexed, parsed, and computed on later.\n[Josiah Parry's](https://bsky.app/profile/josiahparry.com) explainer video goes into more detail about this using another example ([04M45S](https://youtu.be/oIMFZf5dUFA?si=-I-6e1pw0U1BuTMV&t=285)).\n\nIn addition, this [video here](https://www.youtube.com/watch?v=WSwObgqWT3M) from [@oggyinformatics](https://www.youtube.com/@oggyinformatics) has a really good overview and example on the use of a list to capture arguments ([01M02s](https://youtu.be/WSwObgqWT3M?si=qrKN5xuqKh9MLm0u&t=62)).\nIt also contains a really good reminder and example for why you should use a list rather than a vector to capture arguments forwarded using `...`s ([03M05S](https://youtu.be/WSwObgqWT3M?si=8mkdRQinpc_YZniy&t=185)): lists can contain any collection of the same data type, while vectors can only contain data of a single type.\nThat is, vectors will transform all the datatypes to the same type.\nThis is summarized in the following examples.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# lists allow for variables of different types to be captured and retain their original type\nx <- c(1, 2, 3, 4)\n\nfn04 <- function(vector, ...) {\n  args <- list(...)\n  for (i in vector) {\n    print(i)\n  }\n\n  print(args)\n}\n\nfn04(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\nlist()\n```\n\n\n:::\n\n```{.r .cell-code}\n# Now add a string and a boolean via dots\nfn04(x, 'a', TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# why not use a vector? all items get converted to the same type\nfn05 <- function(vector, ...) {\n  args <- c(...)\n  for (i in vector) {\n    print(i)\n  }\n\n  print(args)\n}\n\nfn05(x, 'a', TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] \"a\"    \"TRUE\"\n```\n\n\n:::\n:::\n\n\n\n\nMoveover, other strategies exist to capture and handle arguments passed using dots.\n\n## Going deeper with `...` handling\n\nOnce I realized there's more to the three-dots than the simple forwarding of arguments, I came across other handling strategies.\nThe [R Inferno book](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf) overviews three strategies for handling arguments passed via the three-dots.\nThe first was discussed above: use a list to capture the argument values passed via dots.\n\nAnother strategy is to use `match.call()`.\nThat is,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn06 <- function(...) {\n  extras <- match.call(expand.dots = FALSE)$...\n  return(extras)\n}\n\nfn06(a = 1, b = 2, c = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1\n\n$b\n[1] 2\n\n$c\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\nOr, in situations where your function processes the arguments, then you can use `do.call()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# I couldn't get this to work, and I didn't fully understand what was going on here\nfn07 <- function(data, ...) {\n  dots <- list(...)\n  ans <- do.call(mean, dots[names(dots) %in% spec])\n}\n\nfn07(mtcars, trim = .01)\n```\n:::\n\n\n\n\nWhile reviewing the `do.call()` strategy, it wasn't immediately apparent to me when this would be useful.\nI also couldn't get it to work using the example provided.\nNonetheless, it's an available strategy, so someone likely has a need for it and could likely get it to work.\n\n## Packages extending the three-dots\n\n### `rlang`'s dynamic dots\n\nThe `rlang` package provides [*dynamic dots*](https://rlang.r-lib.org/reference/dyn-dots.html).\nSome of the package's functions extend the functionality of `...`.\nBesides argument forwarding and collection, `rlang`'s dynamic dots provides additional features.\nCheck out the [package's docs](https://rlang.r-lib.org/reference/dyn-dots.html) for a deeper explanation, as the following is just a summary.\n\nDynamic dots implements what's known as *injection*: the process of modifying a piece of code before R processes it.\nDynamic dots has two injection operators, `!!!` and `{`.\nAs such, this extended functionality allows for:\n\n1. argument list splicing\n2. injecting names with glue syntax\n3. trailing commas, which are ignored\n\nAlthough examples are available in the package's documentation, I decided to notate their use as a reminder of how they work.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn08 <- function(...) {\n  out <- rlang::list2(...)\n  return(out)\n}\n\n# list splicing\nx <- list(a = \"one\", b = \"two\")\n\nfn09 <- function(x) {\n  arguments <- fn06(!!!x)\n  return(arguments)\n}\n\nfn08(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[[1]]$a\n[1] \"one\"\n\n[[1]]$b\n[1] \"two\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# name injections, glue syntax\nnm <- \"values\"\nfn08(\"{nm}\" := x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$values\n$values$a\n[1] \"one\"\n\n$values$b\n[1] \"two\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfn08(\"prefix_{nm}\" := x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$prefix_values\n$prefix_values$a\n[1] \"one\"\n\n$prefix_values$b\n[1] \"two\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# ignoring trailing commas\nfn08(x = 6, )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n\nIndeed, `rlang` provides some convenient extensions to `...`'s functionality.\nCheck it out.\n\n### Safer use of `...` with ellipsis\n\nAnother package useful when implementing dots is `rlib`'s [`ellipsis`](https://ellipsis.r-lib.org/) package.\nThe goal of `ellipsis` is to make the use of `...` safer, as some unintended side effects can arise from their use.\nThe package provides three convenience functions to do this:\n\n* `check_dots_used()`\n* `check_dots_unnamed()`\n* `check_dots_empty()`\n\nEach function performs some type of check on the arguments being passed with `...`.\nFrom the documentation, `check_dots_used()` throws an error if any `...` are not evaluated.\n`check_dots_unnamed()` errors if any components of `...` are named.\n`check_dots_empty()` errors if `...` is used.\n\nOne concern of `...` is it can \"silently swallow\" passed arguments.\nSay we want to ensure all the arguments passed to `...` are evaluated.\nThe `check_dots_used()` function can be helpful in this case.\nThis function sets up a handler that evaluates when a function terminates, enforcing that all arguments have been evaluated.\nOtherwise, it will throw an error.\nFor instance,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn09 <- function(...) {\n  ellipsis::check_dots_used()\n  div_vals(...)\n}\n\ndiv_vals <- function(x, y, ...) {\n  x / y\n}\n\n# works, yay!\nfn09(x = 10, y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# doesn't work, because we're trying to process more arguments then are available\ntry(fn09(x = 10, y = 2, z = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in fn09(x = 10, y = 2, z = 1) : Arguments in `...` must be used.\n✖ Problematic argument:\n• z = 1\nℹ Did you misspell an argument name?\n```\n\n\n:::\n\n```{.r .cell-code}\n# also helpful when unevaluated unnamed arguments are passed\ntry(fn09(x = 10, y = 2, 1, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in fn09(x = 10, y = 2, 1, 2, 3) : Arguments in `...` must be used.\n✖ Problematic arguments:\n• ..1 = 1\n• ..2 = 2\n• ..3 = 3\nℹ Did you misspell an argument name?\n```\n\n\n:::\n:::\n\n\n\n\nNamed arguments passed with dots may be misspelled.\nAs such, the `check_dots_unnamed()` function might be useful and a safer option for a function definition.\nFor instance,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# not very safe\nfn10 <- function(..., val_extra = 10) {\n  c(...)\n}\n\n# who hasn't misspelled an argument name before?\nfn10(1, 2, 3, val = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            val \n  1   2   3   4 \n```\n\n\n:::\n\n```{.r .cell-code}\nfn10(1, 2, 3, val_extra = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# safer\nfn11 <- function(..., val_extra = 10) {\n  rlang::check_dots_unnamed()\n  c(...)\n}\n\nfn11(1, 2, 3, val = 10)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `fn11()`:\n! Arguments in `...` must be passed by position, not name.\n✖ Problematic argument:\n• val = 10\n```\n\n\n:::\n\n```{.r .cell-code}\nfn11(1, 2, 3, val_extra = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\n`check_dots_empty()` is useful for when you want users to fully name the details arguments.\nWhile reviewing, I felt this strategy not only enforces this but it also allows for more informative errors to be pushed to the console.\nIt also seems to better handle situations where partial argument matching happens.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn12 <- function(x, ..., foofy = 8) {\n  x + foofy\n}\n\nfn12(3, foofy = 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nfn12(3, foody = 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nfn13 <- function(x, ..., foofy = 8) {\n  rlang::check_dots_empty()\n  x + foofy\n}\n\nfn13(3, foofy = 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nfn13(3, foody = 8)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `fn13()`:\n! `...` must be empty.\n✖ Problematic argument:\n• foody = 8\n```\n\n\n:::\n:::\n\n\n\n\nThe ellipsis package provides some powerful, useful functionality for handling edge cases that come up when forwarding arguments via `...`s.\nCheck it out if you find yourself needing safer `...` handling methods.\n\n## Other concepts to be aware of when using `...`\n\n[This R-bloggers' post](https://www.r-bloggers.com/2020/11/some-notes-when-using-dot-dot-dot-in-r/) provides some additional overview of `...`'s behavior.\nI attempt to summarize some of the points shared in the post below.\n\nThe function receiving the `...`s does not itself need `...`s as an argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn14 <- function(x, ...) {\n  fn15(...)\n}\n\nfn15 <- function(y) {\n  print(y)\n}\n\nfn14(x = 1, y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\nThis is useful because if we pass anything other than `y`, we get an error.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn14(x = 1, y = 2, z = 3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in fn15(...): unused argument (z = 3)\n```\n\n\n:::\n:::\n\n\n\n\nUsing dots within both functions allows for the passing on an additional named argument without error.\nIn this example, the `z` argument.\nThis is not necessarily a utility of the dots, but rather a behavior to note.\nA behavior one would likely want to account for using functions from the [ellipsis package](https://ellipsis.r-lib.org/), which was already discussed above.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn14 <- function(x, ...) {\n  fn15(...)\n}\nfn15 <- function(y, ...) {\n  print(y)\n}\n\nfn14(x = 1, y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nfn14(x = 1, y = 2, z = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n`list(...)` can be used to interpret the arguments passed using `...`.\nWhy? This is helpful when you want to amend the arguments before forwarding them on.\nIn other words, save the output of `list(...)` as a variable, amend this variable, then call the next function with the amended variable using `do.call()`.\nFor instance, from the example from the original post:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn16 <- function(x, ...) {\n  args <- list(...)\n  if (\"y\" %in% names(args)) {\n    args$y <- 2 * args$y\n  }\n  do.call(fn15, args)\n}\n\nfn15 <- function(y) {\n  print(y)\n}\n\nfn16(x = 1, y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\nIn this case, if an argument `y` is included, then it will be captured, and subsequently doubled before being outputted.\nA neat additional strategy for handling forwarded arguments, which has some utility for conditionally modifying argument values based on what's forwarded.\n\n# Wrap up\n\nSo there you have it, a collection of notes on the use of `...`s.\nHere's a summary of what I've learned about using dots when programming in R:\n\n* `...`s are helpful for forwarding any number of additional arguments along to other functions.\n* Several methods exist for capturing and handling arguments passed via `...`s. List capturing, in my view, seems to be the most useful and straight forward.\n* [`rlang`](https://rlang.r-lib.org/index.html)'s [dynamic dots](https://rlang.r-lib.org/reference/dyn-dots.html) provides additional utilities for working with dots.\n* The [`ellipsis` package](https://ellipsis.r-lib.org/) provides convenience functions to make `...`s safer.\n* `...`s have some interesting behavior to be aware of when implented within in an R function.\n\nWhat did I miss? What did I completely get wrong? I'd love the feedback.\n\nIf you found these notes and reflections useful, let's connect:\n\n* BlueSky: [@collinberke.bsky.social](https://bsky.app/profile/collinberke.bsky.social)\n* LinkedIn: [collinberke](https://www.linkedin.com/in/collinberke/)\n* GitHub: [@collinberke](https://github.com/collinberke)\n* [Say Hi!](https://www.collinberke.com/say-hi)\n\n# Additional resources\n\n* [`...` (dot-dot-dot) section from Advanced R](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot)\n* [Dot prefix from Tidy design principles](https://design.tidyverse.org/dots-prefix.html)\n* [Some notes when using dot-dot-dot (…) in R](https://www.r-bloggers.com/2020/11/some-notes-when-using-dot-dot-dot-in-r/)\n* [The three-dots construct in R](https://www.burns-stat.com/the-three-dots-construct-in-r/)\n* [R Inferno section 8.3.15 handling ...](https://www.burns-stat.com/documents/books/the-r-inferno/)\n* [Dynamic dots features from rlang](https://rlang.r-lib.org/reference/dyn-dots.html)\n* [R ... three dots ellipsis](https://www.r-bloggers.com/2015/02/r-three-dots-ellipsis/)\n* [Demystifying ... (dots): R package dev fundamentals](https://www.youtube.com/watch?v=oIMFZf5dUFA)\n* [How to use the ellipsis in R (Tutorial)](https://www.youtube.com/watch?v=WSwObgqWT3M)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}