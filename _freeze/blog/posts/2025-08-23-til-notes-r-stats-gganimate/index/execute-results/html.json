{
  "hash": "e2b9aaf47fbad186eb9c80382adc5ebb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Notes: Using gganimate to animate plots\"\ndescription: \"Learning more about data visualization animation from the 'Getting Started' vignette\"\ndate: \"2025-08-23\"\nauthor: \"Collin K. Berke, Ph.D.\"\ndraft: false\nimage: false\ntoc: true\ncode-link: true\ncode-copy: true\nfrom: markdown+emoji\ncategories:\n  - til\n  - notes\n  - links\n  - data visualization\n---\n\n\n\n\nI recently created a [TidyTuesday](https://www.collinberke.com/blog/posts/2025-08-10-post-tidy-tuesday-2025-08-05-income-inequality-before-and-after-taxes/) data visualization utilizing the [gganimate](https://gganimate.com/articles/gganimate.html) [RStats](https://www.r-project.org/) package.\nWhile using the package, my focus was to 'get something up and running quickly'.\nI wanted to go deeper, though.\nBelow are my notes from diving into the package's ['Getting Started'](https://gganimate.com/articles/gganimate.html) vignette.\n\n::: {.callout-note}\nThis post is written in the spirit of [publishing more frequent blog posts](https://www.collinberke.com/til/posts/2025-01-26-til-notes-quotes-links-credibility-blogs/).\nIt's a bit of a scratchpad of ideas, concepts, and ways of working that I found to be useful or interesting.\nAs such, what's here is lightly edited.\nBe aware: there will likely be spelling, grammatical, or syntactical errors along with some disjointed, incomplete ideas.\n:::\n\n# What is gganimate?\n\ngganimate is an extension ggplot2 package that builds on the [grammar of graphics](https://vita.had.co.nz/papers/layered-grammar.pdf).\nIt provides an API to create animations by adding additional grammar classes, which utilizes syntax similar to ggplot2.\nThe package provides the following family of functions to apply these new grammar classes:\n\n* `transition_*()`\n* `view_*`\n* `shadow_*()`\n* `enter_*()/exit_*()`\n* `ease_aes()`\n\nCheck out the [package's README](https://gganimate.com/).\nIt contains a more in-depth definition of each family of functions.\n\nTo get started, we just need to install `gganimate` by running the following in our console.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"gganimate\")\n```\n:::\n\n\n\n\nThen, we make the package available in our R session by adding in our file's `setup` code chunk (along with the other packages we seek to use):\n\n\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(berkeBrand)\nlibrary(here)\nlibrary(glue)\nlibrary(gganimate)\nlibrary(cfbfastR)\nlibrary(ggtext)\nlibrary(ggrepel)\n```\n:::\n\n\n\n\n# What are the key ideas/functions of gganimate?\n\ngganimate implements several key concepts within its API to create animated data visualizations.\nThese include:\n\n* transitions\n* easing\n* labelling\n* object permanence\n* entering and exiting\n* rendering\n\nIn this post, I provide two examples to highlight the key ideas implemented in gganimate.\nThe first will seek to animate a data visulization of the `penguins` data set, and it will be used to demonstrate how each key idea is implemented within the package.\nThe second will be an extension of the docs, where I visualize some [NCAA Big Ten college football](https://en.wikipedia.org/wiki/College_football) data.\nThe examples here will closely resemble what's already documented in the package's vignette.\nAs such, I highly suggest reviewing the package's docs in addition to these notes.\n\nLet's start with the `penguins` data set, where we can create a static scatterplot of `flipper_len` by `body_mass`.\nIn other words, we want to answer the question: how do bigger flippers relate to a penguin's mass? (i.e., are penguins with longer flippers heavier?).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvis_flip_mass <- ggplot(\n  penguins,\n  aes(flipper_len, body_mass)\n) +\n  geom_point()\n\nvis_flip_mass\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/vis-flip-mass-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\nGreat!\nWe have now a static plot to animate.\n\n## Transitions\n\nTransitions is the first concept to know when using gganimate.\nThe terms/key functions include:\n\n* The `transition_states()` function creates transitions based on some discrete variable within your data.\nThat is, it's main purpose is to split the data into various frames, which are then later complied into a `.gif` file.\nIn the example here, we're splitting by the `species` variable.\n\n* *tweening:* a calculation performed to ensure the transitions between each state of the animation are smooth.\n\nHere's how we create the transitions utilizing the `transitions_states()` function, outputted as a `.gif` file.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_flip_mass_trans <- vis_flip_mass +\n  transition_states(\n    species,\n    transition_length = 2,\n    state_length = 1\n  )\n\nvis_flip_mass_trans\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans.gif){fig-align=\"center\"}\n\n::: {.callout-note}\nWhere's the `.gif`?\n\nI noticed gganimate opens [Preview](https://en.wikipedia.org/wiki/Preview_(macOS)) (I'm on a Mac) after rendering the `.gif` file.\nAs such, all you see is a collection of static plots.\nThis didn't allow me to 'see' the animation.\n\ngganimate writes the `.gif` file to a temporary directory.\nThe `tempdir()` function can be used to print the file path of the temporary directory used for the current R session.\nThis file path can then be used to point a web browser to the location of the `.gif` file.\nThis [video](https://www.youtube.com/watch?v=Hmr6HU2WWcs) does a pretty good job highlighting how to do this using Google Chrome.\n\nThe `anim_save()` function can be used to save the `.gif` file wherever is most convenient.\n:::\n\n## Easing\n\nEasing is the next key concept to know when using the gganimate package.\n\n* Easing: a calculation that takes place to create intermediary data for the tweening to occur.\nIn other words, it's a calculation to specify the velocity of change taking place between the transitions.\ngganimate has various types of easing that can be applied to the transitions.\ngganimate's `ease_aes()` function is used to specify the different types of easing.\n\nHere are a few examples applied to our `penguins` scatterplot:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_flip_mass_trans +\n  ease_aes(\"quintic-in-out\")\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_quintic_in_out.gif){fig-align=\"center\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_flip_mass_trans +\n  ease_aes(\"cubic-in-out\")\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_cubic_in_out.gif){fig-align=\"center\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_flip_mass_trans +\n  ease_aes(\"quadratic-in-out\")\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_quadratic_in_out.gif){fig-align=\"center\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_flip_mass_trans +\n  ease_aes(\"exponential-in-out\")\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_exponential_in_out.gif){fig-align=\"center\"}\n\nA key point here is you have to specify the type of easing function to use, along with a modifier.\nYou can read more about what's available by viewing the `?ease_aes` function's documentation.\nMany combinations are available.\n\n## Labelling\n\nThe ability to add labels to our animations is the next key concept to know.\ngganimate makes it easy to show dynamic labels.\nThis is due to the package providing glue like syntax for plot labelling.\nFor instance, let's say we wanted to include the type of penguin species within the title to match the current state of the data being shown.\nThis can be done by doing the following:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_flip_mass_trans +\n  labs(\n    title = \"Flipper length and body mass for {closest_state} penguins\"\n  )\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_labels.gif){fig-align=\"center\"}\n\ngganimate also makes other transition variables available for labelling.\nThese include `frame` and `nframes`.\nCheck out the [docs](https://gganimate.com/articles/gganimate.html#labeling) for more information and additional examples.\n\n## Object Permanence\n\nObject permanence is another important concept to consider, especially as it relates to the semantics and validity of your plot.\nI think of object permanence like this: data points may not be connected, so the animation applied should avoid implying a connection.\nThis isn't true in all cases (i.e., timeseries data).\nHowever, it's important to consider that if you have distinct classes in your data, the animations should make this clear.\nIn the context of the penguins example, the different penguin species are not related, but with how the animation morphs to different species implies that they are connected--this is not true for this data.\n\nAs the docs mention, we need to tell gganimate to not morph observations between different categories in our data to make it clear that observations are not connected.\nThe docs provide two suggestions for fixing this: add an aesthetic to distinguish between the groups or set the group directly.\nSo, let's apply the doc's preferred fix to our example: set the group directly.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins, aes(flipper_len, body_mass)) +\n  geom_point(aes(colour = species, group = 1L)) +\n  transition_states(\n    species,\n    transition_length = 2,\n    state_length = 1\n  ) +\n  ease_aes(\"cubic-in-out\")\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_permanence.gif){fig-align=\"center\"}\n\nNow the transitions make it a little more clear that these data are separate and not connected.\nThis is done utilizing color and the different transitions states.\nDespite our best efforts, though, a different type of transition might make these more clear.\nThis is where entering and exiting can be applied.\n\n## Entering and Exiting\n\nAs the docs mention, another alternative to fix our problem above is to provide transitions to have data appear and disapear.\nThis is where the `enter_*()` and `exit_*()` family of functions become useful.\n\nLet's apply some of these functions to our `penguins` plot.\nHere's a few examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanim <- ggplot(penguins, aes(flipper_len, body_mass)) +\n  geom_point(aes(colour = species), size = 2) +\n  transition_states(\n    species,\n    transition_length = 2,\n    state_length = 1\n  )\n\nanim +\n  enter_fade() +\n  exit_shrink()\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_enter_shrink.gif){fig-align=\"center\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanim +\n  enter_grow() +\n  exit_recolour(colour = \"#000000\")\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_exit_recolour.gif){fig-align=\"center\"}\n\n# Rendering\n\nNow that we've settled on the specifics of our animation, we need to consider the rendering of the animation.\nIndeed, if we don't want to think about it, the default rendering options are a good start for most situations.\nHowever,  gganimate provides functionality to modify the rendering of the animation for cases where we want flexibility.\nLet's highlight some of these options.\n\nAn animation's number of frames and frame-rate is established at rendering.\nThe `animate()` function runs when an animation is printed, and as a result, default arguments are passed to specify the properties of the rendering.\nThese include:\n\n* `nframes`: number of frames.\n* `fps`: the frames/sec.\n* `dev`: the device to render each frame (e.g., `.png`).\n* `renderer`: the function used to perform the rendering.\n\nIf you have very specific needs for the outputted animation, `...` are available, and you can call `animate()` with these specific options specified.\nIn the background, gganimate uses [gifski](https://github.com/r-rust/gifski) to combine each frame into a `gif` file.\n\nIndeed, in most cases a `.gif` file is what you'll need.\nHowever, gganimate provides additional rendering functions.\nTake for example BlueSky.\nAt least at the time of writing this post, the platform doesn't support the inclusion of user created `.gifs` within posts.\nSo, a video file is needed to share your post.\n`av_renderer()` can be used to output a video file of your animation.\nThe [docs](https://gganimate.com/articles/gganimate.html#rendering) have a pretty good example of how to do this.\n\nJust like with ggplot2, you can specify dimension options like `height` and `width`, along with `res` (i.e., resolution).\nFor instance:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanim <- anim +\n  enter_grow() +\n  exit_recolour(colour = \"#000000\")\n\nanimate(\n  anim,\n  width = 500,\n  height = 500,\n  res = 50\n)\n```\n:::\n\n\n\n\n\n\n![](vis-flip_mass_trans_options.gif){fig-align=\"center\"}\n\nSaving your animation is simple.\nUse `anim_save()` to do this.\n\n# Building on the docs\n\nThese notes aim to build on the docs.\nTo do this, let's create an additional example applying what we learned.\nI work with timeseries data, so let's create an example animating this type of data.\n\nThe 2025 college football season is upon us.\nI'm a Nebraska fan.\nSo let's take a look at some Big Ten quarterback passing yards from last season.\nSpecficially, let's create an animation of cumulative passing yards for each week.\n\nHere's some code to get and transform this data.\nIt utilizes a package from the [SportsDataverse](https://www.sportsdataverse.org/), [cfbfastR](https://cfbfastr.sportsdataverse.org/) to get the passing data for all Big Ten quarterbacks.\nFor the sake of brevity and because data transformation is not the main focus of this post, I won't go into detail explaining each step.\nNonetheless, here's the code needed to get and transform the data for our the following example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_fb_pass <- map_df(\n  1:14,\n  \\(week) {\n    Sys.sleep(3)\n    cfbd_game_player_stats(\n      year = 2024,\n      week = week,\n      conference = \"B1G\",\n      category = \"passing\"\n    ) |>\n      mutate(week = week, .after = game_id)\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nregular_qbs <- data_fb_pass |>\n  count(team, athlete_name, sort = TRUE) |>\n  filter(n > 5) |>\n  pull(athlete_name)\n\ndata_qbs_pass <- data_fb_pass |>\n  filter(\n    conference == \"Big Ten\",\n    athlete_name %in% regular_qbs\n  ) |>\n  select(week, team, athlete_name, passing_yds) |>\n  group_by(team, athlete_name) |>\n  complete(week = 1:14, fill = list(passing_yds = 0)) |>\n  arrange(team, athlete_name, week) |>\n  mutate(\n    cume_pass_yds = cumsum(passing_yds)\n  )\n\ntop_qbs <- data_qbs_pass |>\n  arrange(desc(cume_pass_yds)) |>\n  filter(cume_pass_yds > 2500) |>\n  pull(athlete_name) |>\n  unique()\n\ndata_top_qb_pass <- data_qbs_pass |>\n  filter(athlete_name %in% top_qbs)\n```\n:::\n\n\n\n\n\n\n\n\nWith the data transformed, we start by creating a static plot.\nI do a little abstracting here by setting color scale values as it's own variable: `color_values`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolor_values <- c(\n  \"Dillon Gabriel\" = \"#007030\",\n  \"Billy Edwards\" = \"#E21833\",\n  \"Will Howard\" = \"#A7B1B7\",\n  \"Kurtis Rourke\" = \"#990000\",\n  \"Ethan Garbers\" = \"#2774AE\",\n  \"Drew Allar\" = \"#6CACE4\",\n  \"Max Brosmer\" = \"#7a0019\",\n  \"Dylan Raiola\" = \"#d00000\",\n  \"Miller Moss\" = \"#FFCC00\",\n  \"Luke Altmyer\" = \"#FF5F05\"\n)\n```\n:::\n\n\n\n\nThen, the static plot, `vis_qbs_pass` is created using `ggplot2`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_qbs_pass <- ggplot() +\n  geom_line(\n    data = data_top_qbs_pass,\n    aes(\n      x = week,\n      y = cume_pass_yds,\n      colour = athlete_name,\n      group = athlete_name\n    ),\n    linewidth = 2.5\n  ) +\n  geom_point(\n    data = data_top_qbs_pass,\n    aes(\n      x = week,\n      y = cume_pass_yds,\n      group = athlete_name\n    ),\n    size = 3.5\n  ) +\n  geom_text_repel(\n    data = data_top_qbs_pass,\n    aes(\n      x = week,\n      y = cume_pass_yds,\n      group = athlete_name,\n      label = athlete_name\n    ),\n    force_pull = 0,\n    hjust = 1,\n    direction = \"y\",\n    nudge_x = 2.5,\n    segment.size = 0.2,\n    min.segment.length = 0,\n    size = 4\n  ) +\n  scale_color_manual(values = color_values) +\n  scale_x_continuous(\n    breaks = c(1:14),\n    expand = expansion(mult = 0.1)\n  ) +\n  scale_y_continuous(labels = scales::label_comma()) +\n  labs(\n    title = \"<strong>Big Ten quarterbacks slinged it throughout the 2024 regular season</strong>\",\n    subtitle = \"Some tight competition at the top, but Dillon Gabriel pulled away around week 9\",\n    caption = glue(\"<strong>Source:</strong> cfbfastR<br>\", add_socials()),\n    y = \"Cumulative passing yards\",\n    x = \"Week\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_textbox_simple(size = 18),\n    plot.subtitle = element_textbox_simple(size = 14),\n    plot.caption = element_textbox_simple(halign = 1, vjust = -5),\n    legend.position = \"none\",\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    axis.text = element_text(size = 12)\n  )\n```\n:::\n\n\n\n\nNow the `transitions_reveal()` function is used to split the data into frames based on some variable within the data.\nIn this example, we use the `week` variable for our transitions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanim_top_qbs <- vis_qbs_pass +\n  transition_reveal(\n    week\n  )\n```\n:::\n\n\n\n\nAt this point, it's about setting output options for our animation.\nThe first is to specify the plot object we want to animate: `anim_top_qbs`.\nThe `duration` option is then set to specify the animation's length, in seconds.\n`fps`, or frames per second, follows.\nThen, the size of the animation is configured with the `width` and `height` options.\n`height` and `width` are represented in terms of pixels, though `animate()` makes a `units` argument available if you want to use some other unit to specigy the size.\nLastly, we set a `res`olution value to specify the quality of the images used to make up the animation.\n\n::: {.callout-note}\nKeep front of mind where the output is intended to end up, as the options you select will dictate the animation's size (i.e., KBs or MBs).\nThis will help you make decisions in regards to `duration` and `fps`.\nIndeed, high-quality, smooth animations look great.\nHowever, if intended to be embedded within a blog or website, you may need to make a tradeoff between quality, size, and frames of the animation to limit the size of the final `.gif`.\n:::\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimate(\n  anim_top_qbs,\n  duration = 15,\n  fps = 15,\n  height = 500,\n  width = 700,\n  res = 75\n)\n```\n:::\n\n\n\n\n\n\n![](vis-qbs_big_ten_passing.gif){fig-align=\"center\"}\n\nAwesome! We now have an animated line chart.\n\n# Wrap up\n\nThis set of notes aimed to be a review of the ['Getting Started'](https://gganimate.com/articles/gganimate.html) vignette for the [gganimate](https://gganimate.com/) package.\nThe key concepts I took away from reviewing these docs include:\n\n  * transitions\n  * easing\n  * labelling\n  * object permanence\n  * entering and exiting\n  * rendering\n\nIn addition, the key functions to get started using gganimate include:\n\n  * The `transition_*()` family of functions.\n  * The `ease_*()` family of functions.\n  * The `enter_*()` and `exit_*()` family of functions.\n  * `animate()`\n\nIndeed, the package provides an abundance of functions and APIs to create any number of bespoke animations for you data visualizations.\nOne just has to take the time to explore and experiment, which I look to do in the future.\n\nThis post also provided an additional example to go beyond just reviewing the docs.\nThis example animated time series data of Big Ten QB passing from the 2024 NCAA football season.\n\nIf you found these notes useful or are just interested in plot animations, let's connect:\n\n* BlueSky: [@collinberke.bsky.social](https://bsky.app/profile/collinberke.bsky.social)\n* LinkedIn: [collinberke](https://www.linkedin.com/in/collinberke/)\n* GitHub: [@collinberke](https://github.com/collinberke)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}